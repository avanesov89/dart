// generics / Дженерик - параметаризованный тип. Дженерики - или обобщение, позволяет программе уйти от жесткой привязке к определенным типам. Определить функционал так, чтобы он мог использовать данные любых типов и обеспечить их безопасность. Позволяет задать программе гибкость.

// Generics или обобщения позволяют добавить программе гибкости и уйти от жесткой привязки к определенным типам. Иногда возникает необходимость, определить функционал таким образом, чтобы он мог использовать данные любых типов.

// https://metanit.com/dart/tutorial/4.8.php

void main() {
  Car car = Car(1, 'Ford'); // передаем идентификатор и название
  print(car.id.runtimeType);
}

class Car {
  int id; // идентификатор авто, равно любому целому числу
  String carName; // название авто

  Car(this.id, this.carName); // конструктор

  void move() {
    print('The $carName, id number: $id');
  }
}

// но что делать, если вместо ID хотим использовать другое значение. например, строки Sting. Для добавления гибкости мы можем использовать вместо int - dynamic. и тогда можем использовать строки.
// Но мы не знаем, с каким типом данным нам придется работать, т.е. что мы получаем в ID. например, мы думаем, что там число, а там строка. Можно создать 2 класса, но в данном случае столкнемся с проблемой дублирования кода. В этом случае нам на помощь приходят дженерики.

// к классу Car добавим <T> - с помощью данного выражения мы указываем, что класс Car типизированн определенным типом T , Т еще называется универсальным параметром. И теперь мы можем использовать Т как обычный тип, например, определять переменные данного типа. не обязательно использовать букву Т.

class Car<T> {
  T id; // идентификатор авто, равно любому целому числу
  String carName; // название авто

  Car(this.id, this.carName); // конструктор

  void move() {
    print('The $carName, id number: $id');
  }
}

// соглашения использования параметрических типов:

// Обозначение параметрического типа:      Интерпретация:
// <T>                                       Тип
// <E>                                       Элемент
// <K>                                       Ключ
// <V>                                       Значение

// создаем обобщенный метод

class Car<T> {
  T id; // идентификатор авто, равно любому целому числу
  String carName; // название авто

  Car(this.id, this.carName); // конструктор

  void move<T>(T speed) {
    print('The $carName, id number: $id');
  }
}
